{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"EventDispatcher.js","sources":["file:///Users/rongalivamsi/Desktop/ngo-A/node_modules/src/controls/EventDispatcher.ts"],"sourcesContent":["/*\nDue to @types/three r168 breaking change\nwe have to manually copy the EventDispatcher class from three.js.\nSo this files merges the declarations from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/three/src/core/EventDispatcher.d.ts\nwith the implementation from https://github.com/mrdoob/three.js/blob/dev/src/core/EventDispatcher.js\nMore info in https://github.com/pmndrs/three-stdlib/issues/387\n*/\n\n/**\n * The minimal basic Event that can be dispatched by a {@link EventDispatcher<>}.\n */\nexport interface BaseEvent<TEventType extends string = string> {\n    readonly type: TEventType;\n    // not defined in @types/three\n    target: any;\n}\n\n/**\n * The minimal expected contract of a fired Event that was dispatched by a {@link EventDispatcher<>}.\n */\nexport interface Event<TEventType extends string = string, TTarget = unknown> {\n    readonly type: TEventType;\n    readonly target: TTarget;\n}\n\nexport type EventListener<TEventData, TEventType extends string, TTarget> = (\n    event: TEventData & Event<TEventType, TTarget>,\n) => void;\n\nexport class EventDispatcher<TEventMap extends {} = {}> {\n    // not defined in @types/three\n    private _listeners: any;\n\n    /**\n     * Adds a listener to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n\taddEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\t/**\n     * Checks if listener is added to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n    hasEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): boolean {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\t/**\n     * Removes a listener from an event type.\n     * @param type The type of the listener that gets removed.\n     * @param listener The listener function that gets removed.\n     */\n    removeEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n     * Fire an event type.\n     * @param event The event that gets fired.\n     */\n    dispatchEvent<T extends Extract<keyof TEventMap, string>>(event: BaseEvent<T> & TEventMap[T]): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}"],"names":[],"mappings":";;;;;;;;;;;;;;AA6BO,MAAM,gBAA2C;IAAjD,aAAA;QAEK,8BAAA;QAAA,cAAA,IAAA,EAAA;IAAA;IAAA;;;;GAAA,GAOX,iBACO,IAAA,EACA,QAAA,EACI;QAEV,IAAK,IAAA,CAAK,UAAA,KAAe,KAAA,GAAY,IAAA,CAAK,UAAA,GAAa,CAAA;QAEvD,MAAM,YAAY,IAAA,CAAK,UAAA;QAElB,IAAA,SAAA,CAAW,IAAK,CAAA,KAAM,KAAA,GAAY;YAE3B,SAAA,CAAA,IAAK,CAAA,GAAI,EAAA;QAErB;QAEA,IAAK,SAAA,CAAW,IAAK,CAAA,CAAE,OAAA,CAAS,QAAS,MAAM,CAAA,GAAM;YAEzC,SAAA,CAAA,IAAK,CAAA,CAAE,IAAA,CAAM,QAAS;QAElC;IAED;IAAA;;;;MAAA,GAOG,iBACI,IAAA,EACA,QAAA,EACO;QAEb,IAAK,IAAA,CAAK,UAAA,KAAe,KAAA,GAAmB,OAAA;QAE5C,MAAM,YAAY,IAAA,CAAK,UAAA;QAEhB,OAAA,SAAA,CAAW,IAAK,CAAA,KAAM,KAAA,KAAa,SAAA,CAAW,IAAK,CAAA,CAAE,OAAA,CAAS,QAAS,MAAM,CAAA;IAErF;IAAA;;;;MAAA,GAOG,oBACI,IAAA,EACA,QAAA,EACI;QAEV,IAAK,IAAA,CAAK,UAAA,KAAe,KAAA,GAAY;QAErC,MAAM,YAAY,IAAA,CAAK,UAAA;QACjB,MAAA,gBAAgB,SAAA,CAAW,IAAK,CAAA;QAEtC,IAAK,kBAAkB,KAAA,GAAY;YAE5B,MAAA,QAAQ,cAAc,OAAA,CAAS,QAAS;YAE9C,IAAK,UAAU,CAAA,GAAM;gBAEN,cAAA,MAAA,CAAQ,OAAO,CAAE;YAEhC;QAED;IAED;IAAA;;;MAAA,GAMG,cAA0D,KAAA,EAA0C;QAEtG,IAAK,IAAA,CAAK,UAAA,KAAe,KAAA,GAAY;QAErC,MAAM,YAAY,IAAA,CAAK,UAAA;QACjB,MAAA,gBAAgB,SAAA,CAAW,MAAM,IAAK,CAAA;QAE5C,IAAK,kBAAkB,KAAA,GAAY;YAElC,MAAM,MAAA,GAAS,IAAA;YAGT,MAAA,QAAQ,cAAc,KAAA,CAAO,CAAE;YAErC,IAAA,IAAU,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,IAAI,GAAG,IAAO;gBAEhD,KAAA,CAAO,CAAE,CAAA,CAAE,IAAA,CAAM,IAAA,EAAM,KAAM;YAE9B;YAEA,MAAM,MAAA,GAAS;QAEhB;IAED;AAED","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"file":"OrbitControls.js","sources":["file:///Users/rongalivamsi/Desktop/ngo-A/node_modules/src/controls/OrbitControls.ts"],"sourcesContent":["import {\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\nimport { EventDispatcher } from './EventDispatcher'\nimport { StandardControlsEventMap } from './StandardControlsEventMap'\n\nconst _ray = /* @__PURE__ */ new Ray()\nconst _plane = /* @__PURE__ */ new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher<StandardControlsEventMap> {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n  // Not used in most scenarios, however they can be useful for specific use cases\n  getZoomScale: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  // Dolly in programmatically\n  dollyIn: (dollyScale?: number) => void\n  // Dolly out programmatically\n  dollyOut: (dollyScale?: number) => void\n  // Get the current scale\n  getScale: () => number\n  // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n  setScale: (newScale: number) => void\n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function setScale(newScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale = newScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyOut(dollyScale: number) {\n      setScale(scale / dollyScale)\n    }\n\n    function dollyIn(dollyScale: number) {\n      setScale(scale * dollyScale)\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // Add dolly in/out methods for public API\n\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale)\n      scope.update()\n    }\n\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n      dollyOut(dollyScale)\n      scope.update()\n    }\n\n    this.getScale = () => {\n      return scale\n    }\n\n    this.setScale = (newScale) => {\n      setScale(newScale)\n      scope.update()\n    }\n\n    this.getZoomScale = () => {\n      return getZoomScale()\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n"],"names":["domElement","panLeft","panUp","pan"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 954, "column": 0}, "map": {"version":3,"file":"SVGLoader.js","sources":["file:///Users/rongalivamsi/Desktop/ngo-A/node_modules/src/loaders/SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader extends Loader {\n    constructor(manager) {\n      super(manager)\n\n      // Default dots per inch\n      this.defaultDPI = 90\n\n      // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n      this.defaultUnit = 'px'\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this\n\n      const loader = new FileLoader(scope.manager)\n      loader.setPath(scope.path)\n      loader.setRequestHeader(scope.requestHeader)\n      loader.setWithCredentials(scope.withCredentials)\n      loader.load(\n        url,\n        function (text) {\n          try {\n            onLoad(scope.parse(text))\n          } catch (e) {\n            if (onError) {\n              onError(e)\n            } else {\n              console.error(e)\n            }\n\n            scope.manager.itemError(url)\n          }\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    parse(text) {\n      const scope = this\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return\n\n        const transform = getNodeTransform(node)\n\n        let isDefsNode = false\n\n        let path = null\n\n        switch (node.nodeName) {\n          case 'svg':\n            style = parseStyle(node, style)\n            break\n\n          case 'style':\n            parseCSSStylesheet(node)\n            break\n\n          case 'g':\n            style = parseStyle(node, style)\n            break\n\n          case 'path':\n            style = parseStyle(node, style)\n            if (node.hasAttribute('d')) path = parsePathNode(node)\n            break\n\n          case 'rect':\n            style = parseStyle(node, style)\n            path = parseRectNode(node)\n            break\n\n          case 'polygon':\n            style = parseStyle(node, style)\n            path = parsePolygonNode(node)\n            break\n\n          case 'polyline':\n            style = parseStyle(node, style)\n            path = parsePolylineNode(node)\n            break\n\n          case 'circle':\n            style = parseStyle(node, style)\n            path = parseCircleNode(node)\n            break\n\n          case 'ellipse':\n            style = parseStyle(node, style)\n            path = parseEllipseNode(node)\n            break\n\n          case 'line':\n            style = parseStyle(node, style)\n            path = parseLineNode(node)\n            break\n\n          case 'defs':\n            isDefsNode = true\n            break\n\n          case 'use':\n            style = parseStyle(node, style)\n\n            const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n            const usedNodeId = href.substring(1)\n            const usedNode = node.viewportElement.getElementById(usedNodeId)\n            if (usedNode) {\n              parseNode(usedNode, style)\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n            }\n\n            break\n\n          default:\n          // console.log( node );\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n          }\n\n          transformPath(path, currentTransform)\n\n          paths.push(path)\n\n          path.userData = { node: node, style: style }\n        }\n\n        const childNodes = node.childNodes\n\n        for (let i = 0; i < childNodes.length; i++) {\n          const node = childNodes[i]\n\n          if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n            // Ignore everything in defs except CSS style definitions\n            // and nested defs, because it is OK by the standard to have\n            // <style/> there.\n            continue\n          }\n\n          parseNode(node, style)\n        }\n\n        if (transform) {\n          transformStack.pop()\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1])\n          } else {\n            currentTransform.identity()\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        const path = new ShapePath()\n\n        const point = new Vector2()\n        const control = new Vector2()\n\n        const firstPoint = new Vector2()\n        let isFirstPoint = true\n        let doSetFirstPoint = false\n\n        const d = node.getAttribute('d')\n\n        if (d === '' || d === 'none') return null\n\n        // console.log( d );\n\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i]\n\n          const type = command.charAt(0)\n          const data = command.slice(1).trim()\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true\n            isFirstPoint = false\n          }\n\n          let numbers\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(data)\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'H':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'V':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'L':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'C':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5],\n                )\n                control.x = numbers[j + 2]\n                control.y = numbers[j + 3]\n                point.x = numbers[j + 4]\n                point.y = numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'S':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                )\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'T':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'A':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if start point == end point\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n                const start = point.clone()\n                point.x = numbers[j + 5]\n                point.y = numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'm':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'h':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'v':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'l':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'c':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5],\n                )\n                control.x = point.x + numbers[j + 2]\n                control.y = point.y + numbers[j + 3]\n                point.x += numbers[j + 4]\n                point.y += numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 's':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 't':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = point.x + numbers[j + 0]\n                point.y = point.y + numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'a':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if no displacement\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n                const start = point.clone()\n                point.x += numbers[j + 5]\n                point.y += numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint)\n                path.currentPath.currentPoint.copy(point)\n                isFirstPoint = true\n              }\n\n              break\n\n            default:\n              console.warn(command)\n          }\n\n          // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n          doSetFirstPoint = false\n        }\n\n        return path\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i]\n\n          if (stylesheet.type !== 1) continue\n\n          const selectorList = stylesheet.selectorText\n            .split(/,/gm)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let j = 0; j < selectorList.length; j++) {\n            // Remove empty rules\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n          }\n        }\n      }\n\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y)\n          return\n        }\n\n        x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n        // Ensure radii are positive\n        rx = Math.abs(rx)\n        ry = Math.abs(ry)\n\n        // Compute (x1', y1')\n        const dx2 = (start.x - end.x) / 2.0\n        const dy2 = (start.y - end.y) / 2.0\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n        // Compute (cx', cy')\n        let rxs = rx * rx\n        let rys = ry * ry\n        const x1ps = x1p * x1p\n        const y1ps = y1p * y1p\n\n        // Ensure radii are large enough\n        const cr = x1ps / rxs + y1ps / rys\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          const s = Math.sqrt(cr)\n          rx = s * rx\n          ry = s * ry\n          rxs = rx * rx\n          rys = ry * ry\n        }\n\n        const dq = rxs * y1ps + rys * x1ps\n        const pq = (rxs * rys - dq) / dq\n        let q = Math.sqrt(Math.max(0, pq))\n        if (large_arc_flag === sweep_flag) q = -q\n        const cxp = (q * rx * y1p) / ry\n        const cyp = (-q * ry * x1p) / rx\n\n        // Step 3: Compute (cx, cy) from (cx', cy')\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n        // Step 4: Compute 1 and \n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n        if (ux * vy - uy * vx < 0) ang = -ang\n        return ang\n      }\n\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n        const w = parseFloatWithUnits(node.getAttribute('width'))\n        const h = parseFloatWithUnits(node.getAttribute('height'))\n\n        // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n        // https://spencermortensen.com/articles/bezier-circle/\n        const bci = 1 - 0.551915024494\n\n        const path = new ShapePath()\n\n        // top left\n        path.moveTo(x + rx, y)\n\n        // top right\n        path.lineTo(x + w - rx, y)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n        }\n\n        // bottom right\n        path.lineTo(x + w, y + h - ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n        }\n\n        // bottom left\n        path.lineTo(x + rx, y + h)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n        }\n\n        // back to top left\n        path.lineTo(x, y + ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n        }\n\n        return path\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = true\n\n        return path\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n        const subpath = new Path()\n        subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n        const subpath = new Path()\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n        const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n        const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n        const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n        const path = new ShapePath()\n        path.moveTo(x1, y1)\n        path.lineTo(x2, y2)\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      //\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style) // clone style\n\n        let stylesheetStyles = {}\n\n        if (node.hasAttribute('class')) {\n          const classSelectors = node\n            .getAttribute('class')\n            .split(/\\s/)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined)\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n              return v\n            }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v))\n        }\n\n        addStyle('fill', 'fill')\n        addStyle('fill-opacity', 'fillOpacity', clamp)\n        addStyle('fill-rule', 'fillRule')\n        addStyle('opacity', 'opacity', clamp)\n        addStyle('stroke', 'stroke')\n        addStyle('stroke-opacity', 'strokeOpacity', clamp)\n        addStyle('stroke-width', 'strokeWidth', positive)\n        addStyle('stroke-linejoin', 'strokeLineJoin')\n        addStyle('stroke-linecap', 'strokeLineCap')\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n        addStyle('visibility', 'visibility')\n\n        return style\n      }\n\n      // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n      function getReflection(a, b) {\n        return a - (b - a)\n      }\n\n      // from https://github.com/ppvg/svg-numbers (MIT License)\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + typeof input)\n        }\n\n        // Character groups\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/,\n        }\n\n        // States\n        const SEP = 0\n        const INT = 1\n        const FLOAT = 2\n        const EXP = 3\n\n        let state = SEP\n        let seenComma = true\n        let number = '',\n          exponent = ''\n        const result = []\n\n        function throwSyntaxError(current, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n          error.partial = partial\n          throw error\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number))\n            else result.push(Number(number) * Math.pow(10, Number(exponent)))\n          }\n\n          number = ''\n          exponent = ''\n        }\n\n        let current\n        const length = input.length\n\n        for (let i = 0; i < length; i++) {\n          current = input[i]\n\n          // check for flags\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT\n            number = current\n            newNumber()\n            continue\n          }\n\n          // parse until next number\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue\n            }\n\n            // start new number\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT\n              number = current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT\n              number = current\n              continue\n            }\n\n            // throw on double commas (e.g. \"1, , 2\")\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result)\n              }\n\n              seenComma = true\n            }\n          }\n\n          // parse integer part\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current\n              state = FLOAT\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse decimal part\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double decimal points (e.g. \"1..2\")\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse exponent part\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current\n              continue\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current\n                continue\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result)\n              }\n            }\n          }\n\n          // end of number\n          if (RE.WHITESPACE.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = false\n          } else if (RE.COMMA.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = true\n          } else if (RE.SIGN.test(current)) {\n            newNumber()\n            state = INT\n            number = current\n          } else if (RE.POINT.test(current)) {\n            newNumber()\n            state = FLOAT\n            number = current\n          } else {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // add the last number found (if any)\n        newNumber()\n\n        return result\n      }\n\n      // Units\n\n      const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n      // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1,\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1,\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1,\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1,\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1,\n        },\n        px: {\n          px: 1,\n        },\n      }\n\n      function parseFloatWithUnits(string) {\n        let theUnit = 'px'\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i]\n\n            if (string.endsWith(u)) {\n              theUnit = u\n              string = string.substring(0, string.length - u.length)\n              break\n            }\n          }\n        }\n\n        let scale = undefined\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit]\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n          }\n        }\n\n        return scale * parseFloat(string)\n      }\n\n      // Transforms\n\n      function getNodeTransform(node) {\n        if (\n          !(\n            node.hasAttribute('transform') ||\n            (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n          )\n        ) {\n          return null\n        }\n\n        const transform = parseNodeTransform(node)\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1])\n        }\n\n        currentTransform.copy(transform)\n        transformStack.push(transform)\n\n        return transform\n      }\n\n      function parseNodeTransform(node) {\n        const transform = new Matrix3()\n        const currentTransform = tempTransform0\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          const tx = parseFloatWithUnits(node.getAttribute('x'))\n          const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n          transform.translate(tx, ty)\n        }\n\n        if (node.hasAttribute('transform')) {\n          const transformsTexts = node.getAttribute('transform').split(')')\n\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim()\n\n            if (transformText === '') continue\n\n            const openParPos = transformText.indexOf('(')\n            const closeParPos = transformText.length\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos)\n\n              const array = parseFloats(transformText.slice(openParPos + 1))\n\n              currentTransform.identity()\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    const tx = array[0]\n                    let ty = 0\n\n                    if (array.length >= 2) {\n                      ty = array[1]\n                    }\n\n                    currentTransform.translate(tx, ty)\n                  }\n\n                  break\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    let angle = 0\n                    let cx = 0\n                    let cy = 0\n\n                    // Angle\n                    angle = (array[0] * Math.PI) / 180\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1]\n                      cy = array[2]\n                    }\n\n                    // Rotate around center (cx, cy)\n                    tempTransform1.makeTranslation(-cx, -cy)\n                    tempTransform2.makeRotation(angle)\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                    tempTransform1.makeTranslation(cx, cy)\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                  }\n\n                  break\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    const scaleX = array[0]\n                    let scaleY = scaleX\n\n                    if (array.length >= 2) {\n                      scaleY = array[1]\n                    }\n\n                    currentTransform.scale(scaleX, scaleY)\n                  }\n\n                  break\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                  }\n\n                  break\n              }\n            }\n\n            transform.premultiply(currentTransform)\n          }\n        }\n\n        return transform\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n          v2.set(tempV3.x, tempV3.y)\n        }\n\n        function transfEllipseGeneric(curve) {\n          // For math description see:\n          // https://math.stackexchange.com/questions/4544164\n\n          const a = curve.xRadius\n          const b = curve.yRadius\n\n          const cosTheta = Math.cos(curve.aRotation)\n          const sinTheta = Math.sin(curve.aRotation)\n\n          const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n          const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n          const f1 = v1.applyMatrix3(m)\n          const f2 = v2.applyMatrix3(m)\n\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n          const mFInv = tempTransform1.copy(mF).invert()\n          const mFInvT = tempTransform2.copy(mFInv).transpose()\n          const mQ = mFInvT.multiply(mFInv)\n          const mQe = mQ.elements\n\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n          const rt1sqrt = Math.sqrt(ed.rt1)\n          const rt2sqrt = Math.sqrt(ed.rt2)\n\n          curve.xRadius = 1 / rt1sqrt\n          curve.yRadius = 1 / rt2sqrt\n          curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n          // Do not touch angles of a full ellipse because after transformation they\n          // would converge to a sinle value effectively removing the whole curve\n\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n              return Math.atan2(sinR, cosR)\n            }\n\n            curve.aStartAngle = transformAngle(curve.aStartAngle)\n            curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise\n            }\n          }\n        }\n\n        function transfEllipseNoSkew(curve) {\n          // Faster shortcut if no skew is applied\n          // (e.g, a euclidean transform of a group containing the ellipse)\n\n          const sx = getTransformScaleX(m)\n          const sy = getTransformScaleY(m)\n\n          curve.xRadius *= sx\n          curve.yRadius *= sy\n\n          // Extract rotation angle from the matrix of form:\n          //\n          //  | cos sx   -sin sy |\n          //  | sin sx    cos sy |\n          //\n          // Remembering that tan = sin / cos; and that\n          // `sx`, `sy`, or both might be zero.\n          const theta =\n            sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n          curve.aRotation += theta\n\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1\n            curve.aEndAngle *= -1\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n\n        const subPaths = path.subPaths\n\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i]\n          const curves = subPath.curves\n\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j]\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n              transfVec2(curve.v3)\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isEllipseCurve) {\n              // Transform ellipse center point\n\n              tempV2.set(curve.aX, curve.aY)\n              transfVec2(tempV2)\n              curve.aX = tempV2.x\n              curve.aY = tempV2.y\n\n              // Transform ellipse shape parameters\n\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve)\n              } else {\n                transfEllipseNoSkew(curve)\n              }\n            }\n          }\n        }\n      }\n\n      function isTransformFlipped(m) {\n        const te = m.elements\n        return te[0] * te[4] - te[1] * te[3] < 0\n      }\n\n      function isTransformSkewed(m) {\n        const te = m.elements\n        const basisDot = te[0] * te[3] + te[1] * te[4]\n\n        // Shortcut for trivial rotations and transformations\n        if (basisDot === 0) return false\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n      }\n\n      function getTransformScaleX(m) {\n        const te = m.elements\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n      }\n\n      function getTransformScaleY(m) {\n        const te = m.elements\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n      }\n\n      // Calculates the eigensystem of a real symmetric 2x2 matrix\n      //    [ A  B ]\n      //    [ B  C ]\n      // in the form\n      //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n      //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n      // where rt1 >= rt2.\n      //\n      // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n      // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t\n        const sm = A + C\n        const df = A - C\n        const rt = Math.sqrt(df * df + 4 * B * B)\n\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt)\n          t = 1 / rt1\n          rt2 = A * t * C - B * t * B\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt)\n        } else {\n          // This case needs to be treated separately to avoid div by 0\n\n          rt1 = 0.5 * rt\n          rt2 = -0.5 * rt\n        }\n\n        // Calculate eigenvectors\n\n        if (df > 0) {\n          cs = df + rt\n        } else {\n          cs = df - rt\n        }\n\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = (-2 * B) / cs\n          sn = 1 / Math.sqrt(1 + t * t)\n          cs = t * sn\n        } else if (Math.abs(B) === 0) {\n          cs = 1\n          sn = 0\n        } else {\n          t = (-0.5 * cs) / B\n          cs = 1 / Math.sqrt(1 + t * t)\n          sn = t * cs\n        }\n\n        if (df > 0) {\n          t = cs\n          cs = -sn\n          sn = t\n        }\n\n        return { rt1, rt2, cs, sn }\n      }\n\n      //\n\n      const paths = []\n      const stylesheets = {}\n\n      const transformStack = []\n\n      const tempTransform0 = new Matrix3()\n      const tempTransform1 = new Matrix3()\n      const tempTransform2 = new Matrix3()\n      const tempTransform3 = new Matrix3()\n      const tempV2 = new Vector2()\n      const tempV3 = new Vector3()\n\n      const currentTransform = new Matrix3()\n\n      const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4,\n      })\n\n      const data = { paths: paths, xml: xml.documentElement }\n\n      // console.log( paths );\n      return data\n    }\n\n    static createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n\n      const BIGNUMBER = 999999999\n\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6,\n      }\n\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0,\n      }\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x\n        const x2 = a1.x\n        const x3 = b0.x\n        const x4 = b1.x\n        const y1 = a0.y\n        const y2 = a1.y\n        const y3 = b0.y\n        const y4 = b1.y\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        const t1 = nom1 / denom\n        const t2 = nom2 / denom\n\n        if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n\n          return null\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n            //find position of this endpoints relatively to edge1\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n              return { x: x, y: y, t: classifyResult.t }\n            }\n          }\n\n          return null\n        } else {\n          //3. edges intersect\n\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            }\n          }\n\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n          return { x: x, y: y, t: t1 }\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x\n        const ay = edgeEnd.y - edgeStart.y\n        const bx = p.x - edgeStart.x\n        const by = p.y - edgeStart.y\n        const sa = ax * by - bx * ay\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN\n          classifyResult.t = 0\n          return\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION\n          classifyResult.t = 1\n          return\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT\n          return\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT\n          return\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND\n          return\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND\n          return\n        }\n\n        let t\n\n        if (ax !== 0) {\n          t = bx / ax\n        } else {\n          t = by / ay\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN\n        classifyResult.t = t\n      }\n\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = []\n        const intersections = []\n\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1]\n          const path1EdgeEnd = path1[index]\n\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1]\n            const path2EdgeEnd = path2[index2]\n\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n            if (\n              intersection !== null &&\n              intersectionsRaw.find(\n                (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n              ) === undefined\n            ) {\n              intersectionsRaw.push(intersection)\n              intersections.push(new Vector2(intersection.x, intersection.y))\n            }\n          }\n        }\n\n        return intersections\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new Vector2()\n        boundingBox.getCenter(center)\n\n        const allIntersections = []\n\n        paths.forEach((path) => {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points)\n\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n            })\n          }\n        })\n\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        return allIntersections\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero'\n        }\n\n        const centerBoundingBox = new Vector2()\n        simplePath.boundingBox.getCenter(centerBoundingBox)\n\n        const scanline = [\n          new Vector2(scanlineMinX, centerBoundingBox.y),\n          new Vector2(scanlineMaxX, centerBoundingBox.y),\n        ]\n\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        const baseIntersections = []\n        const otherIntersections = []\n\n        scanlineIntersections.forEach((i) => {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i)\n          } else {\n            otherIntersections.push(i)\n          }\n        })\n\n        const firstXOfPath = baseIntersections[0].point.x\n\n        // build up the path hierarchy\n        const stack = []\n        let i = 0\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop()\n          } else {\n            stack.push(otherIntersections[i].identifier)\n          }\n\n          i++\n        }\n\n        stack.push(simplePath.identifier)\n\n        if (_fillRule === 'evenodd') {\n          const isHole = stack.length % 2 === 0 ? true : false\n          const isHoleFor = stack[stack.length - 2]\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          let isHole = true\n          let isHoleFor = null\n          let lastCWValue = null\n\n          for (let i = 0; i < stack.length; i++) {\n            const identifier = stack[i]\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = false\n              isHoleFor = identifier\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = true\n            }\n          }\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n        }\n      }\n\n      // check for self intersecting paths\n      // TODO\n\n      // check intersecting paths\n      // TODO\n\n      // prepare paths for hole detection\n      let scanlineMinX = BIGNUMBER\n      let scanlineMaxX = -BIGNUMBER\n\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints()\n        let maxY = -BIGNUMBER\n        let minY = BIGNUMBER\n        let maxX = -BIGNUMBER\n        let minX = BIGNUMBER\n\n        //points.forEach(p => p.y *= -1);\n\n        for (let i = 0; i < points.length; i++) {\n          const p = points[i]\n\n          if (p.y > maxY) {\n            maxY = p.y\n          }\n\n          if (p.y < minY) {\n            minY = p.y\n          }\n\n          if (p.x > maxX) {\n            maxX = p.x\n          }\n\n          if (p.x < minX) {\n            minX = p.x\n          }\n        }\n\n        //\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1\n        }\n\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n        }\n      })\n\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier\n      }\n\n      // check if path is solid or a hole\n      const isAHole = simplePaths.map((p) =>\n        isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n        ),\n      )\n\n      const shapesToReturn = []\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier]\n\n        if (!amIAHole.isHole) {\n          const shape = new Shape()\n          shape.curves = p.curves\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier]\n            const path = new Path()\n            path.curves = hole.curves\n            shape.holes.push(path)\n          })\n          shapesToReturn.push(shape)\n        }\n      })\n\n      return shapesToReturn\n    }\n\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n\n      width = width !== undefined ? width : 1\n      color = color !== undefined ? color : '#000'\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n      lineCap = lineCap !== undefined ? lineCap : 'butt'\n      miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit,\n      }\n    }\n\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some width around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n      const vertices = []\n      const normals = []\n      const uvs = []\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null\n      }\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n      return geometry\n    }\n\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n\n      const tempV2_1 = new Vector2()\n      const tempV2_2 = new Vector2()\n      const tempV2_3 = new Vector2()\n      const tempV2_4 = new Vector2()\n      const tempV2_5 = new Vector2()\n      const tempV2_6 = new Vector2()\n      const tempV2_7 = new Vector2()\n      const lastPointL = new Vector2()\n      const lastPointR = new Vector2()\n      const point0L = new Vector2()\n      const point0R = new Vector2()\n      const currentPointL = new Vector2()\n      const currentPointR = new Vector2()\n      const nextPointL = new Vector2()\n      const nextPointR = new Vector2()\n      const innerPoint = new Vector2()\n      const outerPoint = new Vector2()\n\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n      minDistance = minDistance !== undefined ? minDistance : 0.001\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n      // First ensure there are no duplicated points\n      points = removeDuplicatedPoints(points)\n\n      const numPoints = points.length\n\n      if (numPoints < 2) return 0\n\n      const isClosed = points[0].equals(points[numPoints - 1])\n\n      let currentPoint\n      let previousPoint = points[0]\n      let nextPoint\n\n      const strokeWidth2 = style.strokeWidth / 2\n\n      const deltaU = 1 / (numPoints - 1)\n      let u0 = 0,\n        u1\n\n      let innerSideModified\n      let joinIsOnLeftSide\n      let isMiter\n      let initialJoinIsOnLeftSide = false\n\n      let numVertices = 0\n      let currentCoordinate = vertexOffset * 3\n      let currentCoordinateUV = vertexOffset * 2\n\n      // Get initial left and right stroke points\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n      lastPointL.copy(points[0]).sub(tempV2_1)\n      lastPointR.copy(points[0]).add(tempV2_1)\n      point0L.copy(lastPointL)\n      point0R.copy(lastPointR)\n\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]\n\n        // Get next point\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1]\n          } else nextPoint = undefined\n        } else {\n          nextPoint = points[iPoint + 1]\n        }\n\n        // Normal of previous segment in tempV2_1\n        const normal1 = tempV2_1\n        getNormal(previousPoint, currentPoint, normal1)\n\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n        currentPointL.copy(currentPoint).sub(tempV2_3)\n        currentPointR.copy(currentPoint).add(tempV2_3)\n\n        u1 = u0 + deltaU\n\n        innerSideModified = false\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2)\n\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n          nextPointL.copy(currentPoint).sub(tempV2_3)\n          nextPointR.copy(currentPoint).add(tempV2_3)\n\n          joinIsOnLeftSide = true\n          tempV2_3.subVectors(nextPoint, previousPoint)\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n          tempV2_3.subVectors(nextPoint, currentPoint)\n          tempV2_3.normalize()\n          const dot = Math.abs(normal1.dot(tempV2_3))\n\n          // If path is straight, don't create join\n          if (dot > Number.EPSILON) {\n            // Compute inner and outer segment intersections\n            const miterSide = strokeWidth2 / dot\n            tempV2_3.multiplyScalar(-miterSide)\n            tempV2_4.subVectors(currentPoint, previousPoint)\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n            innerPoint.copy(tempV2_5).negate()\n            const miterLength2 = tempV2_5.length()\n            const segmentLengthPrev = tempV2_4.length()\n            tempV2_4.divideScalar(segmentLengthPrev)\n            tempV2_6.subVectors(nextPoint, currentPoint)\n            const segmentLengthNext = tempV2_6.length()\n            tempV2_6.divideScalar(segmentLengthNext)\n            // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint)\n            innerPoint.add(currentPoint)\n\n            isMiter = false\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint)\n                currentPointR.copy(innerPoint)\n              } else {\n                nextPointL.copy(innerPoint)\n                currentPointL.copy(innerPoint)\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n\n              makeSegmentTriangles()\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n                break\n\n              case 'round':\n                // Segment triangles\n\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n                }\n\n                break\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                    break\n                  } else {\n                    // Segment triangles\n\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                    // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(tempV2_7, u1, 0)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(tempV2_7, u1, 1)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 0)\n\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(innerPoint, u1, 1)\n                    } else {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 1)\n\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(innerPoint, u1, 0)\n                      addVertex(outerPoint, u1, 1)\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint)\n                    } else {\n                      nextPointR.copy(outerPoint)\n                    }\n                  } else {\n                    // Add extra miter join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n\n                  isMiter = true\n                }\n\n                break\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n\n            makeSegmentTriangles()\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n\n          makeSegmentTriangles()\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n        }\n\n        // Increment loop variables\n\n        u0 = u1\n\n        previousPoint = currentPoint\n\n        lastPointL.copy(nextPointL)\n        lastPointR.copy(nextPointR)\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n        let lastOuter = outerPoint\n        let lastInner = innerPoint\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint\n          lastInner = outerPoint\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3)\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3)\n            }\n          }\n        }\n      }\n\n      return numVertices\n\n      // -- End of algorithm\n\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1)\n        return result.set(-result.y, result.x).normalize()\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x\n          vertices[currentCoordinate + 1] = position.y\n          vertices[currentCoordinate + 2] = 0\n\n          if (normals) {\n            normals[currentCoordinate] = 0\n            normals[currentCoordinate + 1] = 0\n            normals[currentCoordinate + 2] = 1\n          }\n\n          currentCoordinate += 3\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u\n            uvs[currentCoordinateUV + 1] = v\n\n            currentCoordinateUV += 2\n          }\n        }\n\n        numVertices += 3\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n\n        tempV2_1.copy(p1).sub(center).normalize()\n        tempV2_2.copy(p2).sub(center).normalize()\n\n        let angle = Math.PI\n        const dot = tempV2_1.dot(tempV2_2)\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n        angle /= arcDivisions\n\n        tempV2_3.copy(p1)\n\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n          addVertex(tempV2_3, u, v)\n          addVertex(tempV2_4, u, v)\n          addVertex(center, u, 0.5)\n\n          tempV2_3.copy(tempV2_4)\n        }\n\n        addVertex(tempV2_4, u, v)\n        addVertex(p2, u, v)\n        addVertex(center, u, 0.5)\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1)\n        addVertex(lastPointL, u0, 0)\n        addVertex(currentPointL, u1, 0)\n\n        addVertex(lastPointR, u0, 1)\n        addVertex(currentPointL, u1, 0)\n        addVertex(currentPointR, u1, 1)\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(innerPoint, u, 0.5)\n          } else {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointR, u, 1)\n            addVertex(innerPoint, u, 0)\n            addVertex(nextPointR, u, 1)\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          } else {\n            addVertex(currentPointR, u, 1)\n            addVertex(nextPointR, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPointL, u0, 0)\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(nextPointL, u0, 0)\n            addVertex(innerPoint, u1, 1)\n          } else {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(currentPointR, u0, 1)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPoint, u1, 0.5)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 0)\n            addVertex(nextPointR, u0, 1)\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5)\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5)\n            }\n\n            break\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n                tempV2_4.toArray(vertices, 3 * 3)\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3)\n                // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n              }\n            } else {\n              tempV2_1.subVectors(p2, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              const vl = vertices.length\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              }\n            }\n\n            break\n\n          case 'butt':\n          default:\n            // Nothing to do here\n            break\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n\n        let dupPoints = false\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true\n            break\n          }\n        }\n\n        if (!dupPoints) return points\n\n        const newPoints = []\n        newPoints.push(points[0])\n\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n            newPoints.push(points[i])\n          }\n        }\n\n        newPoints.push(points[points.length - 1])\n\n        return newPoints\n      }\n    }\n  }\n\n  return SVGLoader\n})()\n\nexport { SVGLoader }\n"],"names":["SVGLoader","node","data","i","current","currentTransform","scanlineMinX","scanlineMaxX","p","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}